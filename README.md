# Notes and Additions

## Architecture
MIPS

## Build Instructions
To compile the project, run:
```bash
javac -d badlang/target/classes badlang/src/main/java/edu/wisc/*.java
```
To run the compiled code, run:
```bash
java -cp badlang/target/classes edu.wisc.Main <Target Badlang File>
```

## Testing

### QtSpim
All assembly code was tested using QtSpim MIPS simulator.

QtSpim may automatically add an exception handler and other code to the beginning of a file. To avoid this, assembly generated by this compiler should be run without QtSpimâ€™s exception handler enabled. To disable this:
1. In the top-left of QtSpim, open the "Simulator" tab.
2. Open "Settings".
3. In settings, open the "MIPS" tab.
4. Uncheck the box that says "Load Exception Handler".
5. Close out of settings.
6. In the top-left of QtSpim, press the net icon to reinitialize the simulator.
7. Load and run your assembly files.

### Complex Tests
For the complex tests, you will notice that for each .bl file, there is a corresponding .c file. These .c files are virtually identical to the .bl files, except the function definitions and print statements are switched to match with C. Since these are tests for the compiler, logic errors in any of the complex tests are not of particular importance, so these .c files are to ensure that the output from my compiler is consistent with a known working compiler rather than me getting stuck on any small logic errors in the Badlang code.

### Compiling Tests
In the tests folder, there is the compileAll.sh file. This file simply runs my compiler on all of the tests Badlang files. It can be run with:
```
sh badlang/tests/compileAll.sh
```
from outside of the badlang folder.

### Symbol Table
If you would like the view the symbol table for any compiled program, simply change the class variable 'debug' in Main.java from false to true. When true, the symbol table will be printed for each compiled program.

## Rules

### Executable Code
All executable code must reside inside of a function. Only global variable declarations and function declarations may be outside of a function.

### Main Function
A main function must exist as the starting point of the code.

### Global Variables
The initial values for global variables must be known at compile time. That is, a global variable cannot be initialized to a function call.

Setting a global variable to the result of a function call within a function is ok.

## Behaviors

### Print Statements
After years of tumultuous development, compiler scientists at the University of Wisconsin - Madison are happy to announce the next innovation in Badlang printing technology. The printsp and println commands!

```
print [expr];
```
We all know it. We all love it. Does exactly what it says it will do, prints the expression and nothing more.

```
printsp [expr];
```
An exciting new edition to the output apparatus. This lovely new statement will print the expression followed by a space.

```
println [expr];
```
But they didn't stop there. With the println command, you can print an expression followed by a whole linebreak!

### Booleans
For purposes such as printing, booleans will be treated as 1s and 0s, with true equalling 1 and false equalling 0.

This affects how the compiler internally handles booleans at the code generation step and if a boolean is printed, it will print the number equivalent.

Booleans still may not be used as integers in arithmetic.

## New Features

### Modulo
The modulo '%' operator is now a part of Badlang. It can be used as part of expressions and has the same precedence as multiplication and division.
```
10 % 3;
```

## Limitations and Issues



# P5: Badlang Code Generation

## Overview

**Congratulations!** You've made it to the final programming assignment in the compilers course! 

In this assignment, you will implement **machine code generation** for the badlang programming language. This is where your compiler finally produces executable code that can run on real (or simulated) hardware. You will transform your abstract syntax tree (AST) into actual assembly instructions.

This assignment is **open-ended** by design. Code generation is complex and requires you to make many design decisions. You have the freedom to choose your target architecture and implementation strategy.

## Target Architecture: Your Choice!

You have two options for your target architecture:

 **Option 1: MIPS Assembly** (Recommended)
- Covered extensively in lecture
- Simple, regular instruction set
- Easy to test with SPIM simulator


 **Option 2: x86 Assembly**
- More complex but widely used

Choose the architecture you're more comfortable with. MIPS is recommended if you followed along with the lecture examples.

## Requirements

1. **Generate Valid Assembly Code**
   - Your compiler must output valid assembly code for your chosen architecture that:
     - Can be assembled and run (in a simulator or on real hardware)
     - Correctly implements the semantics of the badlang program
     - Produces the expected output

2. **Testing Strategy**
   - Since testing is not simple, you will need to
     - Use a simulator (e.g., SPIM for MIPS)
     - Create test programs and verify their output
     - Document your testing approach

## Deliverables

Submit a zip file of the `P5` folder containing:

1. **Your source code**: All Java files for your code generator
2. **Tests**: At least 10 example programs that demonstrate different language features
3. **README additions**: Add a section to this README documenting:
   - Which architecture you chose (MIPS or x86)
   - How to build and run your compiler
   - How you tested the generated code
   - Known limitations or issues
   - **If you worked with a partner, include both names at the top**

## Grading Rubric

Your assignment will be graded on:

### 1. **Correctness (50%)**
- Does the generated code run correctly?
- Does it produce the expected output?

### 2. **Completeness (25%)**
- Are all language features implemented?
- Literals, variables, expressions
- Control flow (if, while)
- Functions and calling conventions
- Print statements

### 3. **Code Quality (10%)**
- Is your code generator well-organized?
- Is the generated assembly code readable?
- Did you follow good software engineering practices?
- Is your code well-commented?

### 4. **Testing (15%)**
- Did you create comprehensive test programs?
- Did you test all language features?
- Did you document your testing approach?

**Remember**: This assignment is open-ended by design. There's no single "correct" approach. Make reasonable design decisions, document them, and focus on getting working code that passes your tests.

--

## Resources
- MIPS tutorial: https://minnie.tuhs.org/CompArch/Resources/mips_quick_tutorial.html
- code generation with MIPS notes: https://pages.cs.wisc.edu/~aws/courses/cs536/readings/codegen.html
- This is the MIPS simulator: https://spimsimulator.sourceforge.net
